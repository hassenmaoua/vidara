package edu.esprit.apigateway.config;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.context.annotation.Bean;import org.springframework.core.io.buffer.DataBuffer;import org.springframework.http.HttpStatus;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.http.server.reactive.ServerHttpResponse;import org.springframework.stereotype.Component;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;import org.springframework.web.cors.reactive.CorsWebFilter;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.List;@Component@Slf4jpublic class AuthenticationFilter implements GatewayFilter {    private final JwtUtil jwtUtil;    public AuthenticationFilter(JwtUtil jwtUtil) {        this.jwtUtil = jwtUtil;    }    @Override    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {        ServerHttpRequest request = exchange.getRequest();        // Skip authentication for auth service endpoints        if (isAuthEndpoint(request)) {            return chain.filter(exchange);        }        String authHeader = request.getHeaders().getFirst("Authorization");        if (authHeader == null || !authHeader.startsWith("Bearer ")) {            return handleUnauthorized(exchange);        }        String token = authHeader.substring(7);        try {            if (!jwtUtil.validateToken(token)) {                return handleUnauthorized(exchange);            }            // Add user info to request headers for downstream services            String username = jwtUtil.extractUsername(token);            List<String> roles = jwtUtil.extractRoles(token);            ServerHttpRequest modifiedRequest = request.mutate()                    .header("X-User-Id", username)                    .header("X-User-Roles", String.join(",", roles))                    .build();            return chain.filter(exchange.mutate().request(modifiedRequest).build());        } catch (Exception e) {            log.error("Authentication error: {}", e.getMessage());            return handleUnauthorized(exchange);        }    }    private boolean isAuthEndpoint(ServerHttpRequest request) {        String path = request.getPath().toString();        return path.contains("/auth/") ||                path.contains("/login") ||                path.contains("/register") ||                path.contains("/swagger") ||                path.contains("/actuator");    }    private Mono<Void> handleUnauthorized(ServerWebExchange exchange) {        ServerHttpResponse response = exchange.getResponse();        response.setStatusCode(HttpStatus.UNAUTHORIZED);        String body = "{\"error\":\"Unauthorized\",\"message\":\"Invalid or missing token\"}";        DataBuffer buffer = response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));        response.getHeaders().add("Content-Type", "application/json");        return response.writeWith(Mono.just(buffer));    }    @Bean    public CorsWebFilter corsWebFilter() {        CorsConfiguration corsConfig = new CorsConfiguration();        corsConfig.setAllowedOriginPatterns(Arrays.asList("*"));        corsConfig.setMaxAge(3600L);        corsConfig.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));        corsConfig.setAllowedHeaders(Arrays.asList("*"));        corsConfig.setAllowCredentials(true);        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        source.registerCorsConfiguration("/**", corsConfig);        return new CorsWebFilter(source);    }}